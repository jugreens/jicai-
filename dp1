#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+10;
const int mod = 1e9+7;
int q, k, dp[maxn][2], l, r;
int main() {
    while(scanf("%d%d", &q, &k) != EOF) {
        dp[0][0] = 0;
        for (int i = 1 ; i < maxn ; i++) {
            if (i < k) dp[i][0] = dp[i - 1][0] + 1;
            else {
                dp[i][0] = (dp[i - 1][0]+dp[i-1][1] + 1) % mod;
                dp[i][1] = (dp[i - k][0] + 1) % mod;
            }
        }
        for (int i = 0 ; i < q ; i++) {
            scanf("%d%d", &l, &r);
            int ans = ((dp[r][0] + dp[r][1]) - (dp[l - 1][0] + dp[l - 1][1])) % mod;
            printf("%d\n", ans);
        }
    }
    return 0;
}
//https://www.cnblogs.com/qldabiaoge/p/9346289.html



//https://blog.csdn.net/dllpXFire/article/details/81131802

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+10;
const int mod = 1e9+7;
int dp[N][11] , a[N] ;
int sum[N];
int main()
{
    int n ,m ,  k ;
    while(~scanf("%d %d %d",&n,&m,&k))
    {
        memset(dp,0,sizeof(dp));
        memset(a,0,sizeof(a));
        memset(sum,0,sizeof(sum));
        for(int i = 1 ; i <= n ; i++)
            cin >> a[i];
        sum[0]=1;
        for(int i = 1 ; i <= n ; i++)
        {
            for(int j = i ; j>=1&&j>=i-m-1 ; j--)
            {
                sum[j] += (sum[j-1]-dp[j][a[i]]);
                sum[j]%=mod;
                dp[j][a[i]]=sum[j-1];
            }
        }
        int ans = (sum[n-m]+mod)%mod;
        cout <<ans <<endl;
    }
    return 0;
}


//https://ac.nowcoder.com/acm/problem/21738
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+50;
const int mod = 1e9+7;
typedef long long LL;
int dp[11][N],n,k;
vector<int> a[N];
int main(void)
{
	cin>>n>>k;
	for(int i=1; i<=k; i++)  //倍数预处理
		for(int j=2; i*j<=k; j++)
			a[i].push_back(i*j);

	memset(dp,0,sizeof(dp));  //边界初始化
	for(int i=1; i<=k; i++) dp[1][i] = 1;

	for(int i=2; i<=n; i++)  //位数枚举
	{
		LL ans = 0,sum=0,temp;  //注意这里要long long，防爆
		for(int j=1; j<=k; j++) ans = (ans+dp[i-1][j])%mod;  //前面的方案数总和
		for(int j=1; j<=k; j++)
		{
			temp = ans;
			dp[i][j] = (sum+dp[i-1][j])%mod;
			sum = (sum+dp[i-1][j])%mod;  //状态的累计
			temp = (temp+mod-sum)%mod;
			for(int q=0; q<a[j].size(); q++)
				temp = (temp+mod-dp[i-1][a[j][q]])%mod;  //枚举倍数减去
			dp[i][j] = (dp[i][j]+temp)%mod;
		}
	}
	LL res = 0;
	for(int i=1; i<=k; i++) res = (LL)(res+dp[n][i])%mod;
	cout<<res<<endl;
	return 0;
}


