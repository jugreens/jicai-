
#include <stdio.h>
#include <algorithm>
#define Lson node[h].lson
#define Rson node[h].rson
#define MID (node[h].lson+node[h].rson)>>1
#define LL long long
using namespace std;
const int maxn = 1e5 + 10 ;
struct Point
{
    int op ;
    int id ;
    int col ;
}point[maxn << 1];
int n , m ;

struct Node
{
    int lson , rson ;
    int color ;
}node[maxn << 2];

int cmp1(Point a , Point b)
{
    return a.id < b.id ;
}

int cmp2(Point a , Point b)
{
    if (a.col > b.col)
        return 1 ;
    else if (a.col == b.col)
    {
        if (a.op < b.op)
            return 1 ;
        else
            return 0 ;
    }
    else
        return 0 ;
}

void Build (int l , int r , int h)
{
    Rson = r ;
    Lson = l ;
    node[h].color = 0 ;
    if (l == r)
        return ;
    int mid = MID ;
    Build (l , mid , h << 1) ;
    Build (mid + 1 , r , h << 1 | 1) ;
}

int Update(int l , int r , int h)
{

    int p ;
    //printf ("%d %d %d\n" , Lson , Rson , h) ;
   if (node[h].color)
        return 0 ;
    if (l == Lson && r == Rson)
    {
        node[h].color = 1 ;
        return 1 ;
    }
   int mid = MID ;
   if (r <= mid)
        p = Update (l , r , h << 1) ;
   else if (l > mid)
        p = Update (l , r , h << 1 | 1) ;
   else
   {
       p = Update (l , mid , h << 1) + Update(mid + 1, r , h << 1 | 1) ;
   }
   if(node[h << 1].color && node[h << 1 | 1].color)
        node[h].color = 1 ;
   return p ;
}


int main ()
{
    int T ;
    scanf ("%d" , &T) ;
    while (T--)
    {
        scanf ("%d" , &n) ;
        for (int i = 1 ; i <= 2 * n - 1 ; i += 2)
        {
            scanf ("%d%d" , &point[i].id , &point[i + 1].id) ;
            point[i].col = point[i + 1].col = i / 2 + 1 ;
            point[i].op = 1 , point[i + 1].op = 2 ;
        }
        sort (point + 1 , point + 1 + 2 * n , cmp1) ;
        int now = 0 , last = -1;
        for (int i = 1 ; i <= 2 * n ; ++i)
        {
            if (point[i].id == last)
            {
                point[i].id = now ;
            }
            else
            {
                last = point[i].id ;
                point[i].id = ++now ;
            }
        }
        sort (point + 1 , point + 1 + 2 * n , cmp2) ;
        Build (1 , now , 1);
        int res = 0 ;

        for (int i = 1 ; i <= 2 * n - 1 ; i += 2)
        {
            if(Update(point[i].id , point[i + 1].id , 1))
                ++res ;
        }
        printf ("%d\n" , res) ;
    }
}


/*
#include<bits/stdc++.h>
using namespace std ;

int n ,m;
int num[100] ;
int order[100] ;
int sz ;
int main ()
{
    scanf ("%d %d" , &n,&m) ;
    for (int i = 1 ; i <= n ; ++i)
    {
        scanf ("%d" , &num[i]) ;
        order[i] = num[i] ;
    }
    sort (order + 1 , order + 1 + n) ;
    sz = unique(order + 1 , order + n + 1) - (order + 1) ;去重数组大小
    //cout << sz <<endl;

    for (int i = 1 ; i <= n ; ++i)
        num[i] = lower_bound(order + 1 , order + sz + 1 , num[i]) - order ;
    for (int i = 1 ; i <= n ; ++i)
        printf ("%d " , num[i]) ;

}
离散化

*/
